from datetime import datetime
from typing import List, Optional
from uuid import UUID

from domain.interfaces.repositories import (
    IBarbeariaRepository,
    IBarbeiroRepository,
    IServicoRepository,
    IClienteRepository,
    IFilaRepository
)
from domain.entities import FilaStatus, FilaPrioridade, EntradaFila, Barbeiro
from domain.services.wait_time_calculator import WaitTimeCalculator


class QueueService:
    """Domain service for queue operations"""
    
    def __init__(
        self,
        fila_repository: IFilaRepository,
        barbearia_repository: IBarbeariaRepository,
        barbeiro_repository: IBarbeiroRepository,
        servico_repository: IServicoRepository,
        cliente_repository: IClienteRepository
    ):
        self.fila_repository = fila_repository
        self.barbearia_repository = barbearia_repository
        self.barbeiro_repository = barbeiro_repository
        self.servico_repository = servico_repository
        self.cliente_repository = cliente_repository
    
    def add_to_queue(
        self,
        barbearia_id: UUID,
        cliente_id: UUID,
        servico_id: UUID,
        preferred_barbeiro_id: Optional[UUID] = None
    ) -> Optional[EntradaFila]:
        """Add a client to the queue if the barbershop is open and not at capacity"""
        
        # Check if barbershop is open
        if not self.barbearia_repository.is_open(barbearia_id):
            return None
        
        # Check if queue is at capacity
        if self.barbearia_repository.is_queue_full(barbearia_id):
            return None
        
        # Get client priority level
        priority_level = self.cliente_repository.get_priority_level(cliente_id)
        
        # Get service duration
        service_duration = self.servico_repository.get_duration(servico_id)
        
        # Calculate position in queue
        waiting_entries = self.fila_repository.get_waiting_entries(barbearia_id)
        position = len(waiting_entries) + 1
        
        # Create queue entry
        new_entry = EntradaFila(
            id=None,  # Will be generated by repository
            barbearia_id=str(barbearia_id),
            cliente_id=str(cliente_id),
            servico_id=str(servico_id),
            barbeiro_id=str(preferred_barbeiro_id) if preferred_barbeiro_id else None,
            status=FilaStatus.AGUARDANDO,
            prioridade=FilaPrioridade(priority_level),
            horario_chegada=datetime.now(),
            horario_atendimento=None,
            horario_finalizacao=None,
            estimativa_duracao=service_duration,
            position_number=position,
            notified=False
        )
        
        # Add to repository
        return self.fila_repository.add_entry(new_entry)
    
    def assign_next_client(self, barbeiro_id: UUID) -> Optional[EntradaFila]:
        """Assign the next client in the queue to a barber"""
        
        # Get barber
        barbeiro = self.barbeiro_repository.get_by_id(barbeiro_id)
        if not barbeiro:
            return None
        
        # Get waiting entries for the barbershop
        waiting_entries = self.fila_repository.get_waiting_entries(UUID(barbeiro.barbearia_id))
        if not waiting_entries:
            return None
        
        # Sort by priority and arrival time
        sorted_entries = sorted(
            waiting_entries,
            key=lambda e: (
                -e.prioridade.value,  # Higher priority first
                e.horario_chegada     # Earlier arrival time first
            )
        )
        
        # Get the next entry
        next_entry = sorted_entries[0]
        
        # Update entry with barber and status
        next_entry.barbeiro_id = str(barbeiro_id)
        next_entry.status = FilaStatus.ATENDIMENTO
        next_entry.horario_atendimento = datetime.now()
        
        # Update repository
        return self.fila_repository.update_entry(next_entry)
    
    def complete_service(self, entrada_id: UUID) -> Optional[EntradaFila]:
        """Mark a service as completed"""
        
        # Get entry
        entry = self.fila_repository.get_by_id(entrada_id)
        if not entry:
            return None
        
        # Check if entry is in service
        if entry.status != FilaStatus.ATENDIMENTO:
            return None
        
        # Update entry status
        entry.status = FilaStatus.FINALIZADO
        entry.horario_finalizacao = datetime.now()
        
        # Update repository
        return self.fila_repository.update_entry(entry)
    
    def cancel_entry(self, entrada_id: UUID) -> Optional[EntradaFila]:
        """Cancel a queue entry"""
        
        # Get entry
        entry = self.fila_repository.get_by_id(entrada_id)
        if not entry:
            return None
        
        # Check if entry can be cancelled
        if entry.status not in [FilaStatus.AGUARDANDO, FilaStatus.ATENDIMENTO]:
            return None
        
        # Update entry status
        entry.status = FilaStatus.CANCELADO
        
        # Update repository
        return self.fila_repository.update_entry(entry)
    
    def mark_as_no_show(self, entrada_id: UUID) -> Optional[EntradaFila]:
        """Mark a client as no-show"""
        
        # Get entry
        entry = self.fila_repository.get_by_id(entrada_id)
        if not entry:
            return None
        
        # Check if entry is waiting
        if entry.status != FilaStatus.AGUARDANDO:
            return None
        
        # Update entry status
        entry.status = FilaStatus.AUSENTE
        
        # Update repository
        return self.fila_repository.update_entry(entry)
    
    def calculate_wait_time(self, barbearia_id: UUID) -> int:
        """Calculate estimated wait time for a barbershop"""
        
        # Get waiting entries
        waiting_entries = self.fila_repository.get_waiting_entries(barbearia_id)
        if not waiting_entries:
            return 0
        
        # Get barbers currently working
        available_barbers = self.barbeiro_repository.get_available_barbers(barbearia_id)
        barber_count = len(available_barbers)
        
        if barber_count == 0:
            return 0  # No barbers available
        
        # Get in-service entries to calculate remaining time
        in_service = self.fila_repository.get_in_service_entries(barbearia_id)
        
        # Sum up estimated duration for waiting entries
        service_durations = [entry.estimativa_duracao for entry in waiting_entries]
        
        # Use the consolidated WaitTimeCalculator service
        return WaitTimeCalculator.calculate(service_durations, barber_count)
        
    def format_wait_time(self, minutes: int) -> str:
        """Format wait time into human-readable string"""
        return WaitTimeCalculator.format_wait_time(minutes) 